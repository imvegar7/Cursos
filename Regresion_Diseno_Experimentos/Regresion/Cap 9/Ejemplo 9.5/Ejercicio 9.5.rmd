---
title: "Ejercicio 9.5 de MPV"
author: "Freddy Hernández"
date: "4 May 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Objetivo

En este ejercicio se busca encontrar un modelo de regresión lineal que explique la variable respuesta $y$ en función de las covariables presentadas en la tabla b3 del texto.

## La base de datos
A continuación se muestra el encabezado de la base de datos y la definición de las variables.

<img src="datos.png" width="800">

__Nota__: Type of transmission (1=automatic, 0=manual).

Antes de iniciar es necesario revisar si hay `NA's` y eliminarlos.

```{r, message=F}
require(MPV)
table.b3[22:26, ] # Can you see the missing values?
datis <- table.b3[-c(23,25), ]
```

El objeto `datis` tiene la base de datos sin las líneas con `NA`, lo mismo se hubiese podido realizar usando la función `na.omit`.

## Aplicación del método __backward__
Vamos a crear un modelo _saturado_.
```{r}
full.model <- lm(y ~ ., data = datis)
summary(full.model)
```
De la tabla anterior se puede pensar en un efecto de <span style="color:red">enmascaramiento</span> entre las variables.

Se usa la función `stepAIC` y se elije `trace=TRUE` para obtener detalles del proceso de selección.
```{r, message=F}
require(MASS)  # Para poder usar la función stepAIC
modback <- stepAIC(full.model, trace=TRUE, direction="backward")
```
Para obtener un resumen del proceso se usa:
```{r}
modback$anova
```
Para ver la tabla de resultados del modelo `modback`.
```{r}
summary(modback)
```

## Aplicación del método __forward__
Para aplicar este método se debe crear un modelo vacío del cual iniciará el proceso. Es necesario definir un punto final de búsqueda, ese punto es una `formula` que en este caso llamaremos `horizonte`. A continuación el código.

```{r}
empty.model <- lm(y ~ 1, data = datis)
horizonte <- formula(lm(y ~ ., data = datis))
```
Se usa la función `stepAIC` y se elije `trace=FALSE` para que NO se muestren los detalles del proceso de selección.
```{r, message=F}
modforw <- stepAIC(empty.model, trace=FALSE, direction="forward", scope=horizonte)
modforw$anova
```
Para ver la tabla de resultados del modelo `modforw`.
```{r}
summary(modforw)
```

## Aplicación del método __both__
Para aplicar este método se debe crear un modelo vacío del cual iniciará el proceso. Es necesario definir un punto final de búsqueda, ese punto es una `formula` que en este caso llamaremos `horizonte`. A continuación el código.

```{r}
modboth <- stepAIC(empty.model, trace=FALSE, direction="both", scope=horizonte)
modboth$anova
```

## Comparación de los dos modelos

### 1. Comparando coeficientes
```{r}
coef(modback)
coef(modforw)
coef(modboth)
```

### 2. Comparando $R^2_{Adj}$
```{r}
summary(modback)$adj.r.squared
summary(modforw)$adj.r.squared
summary(modboth)$adj.r.squared
```

### 3. Comparando los residuales
```{r, message=F, fig.asp=0.4, fig.width=10}
par(mfrow=c(1, 3))
require(car)
qqPlot(modback, main="Backward", pch=19, cex=1.5)
qqPlot(modforw, main="Forward", pch=19, cex=1.5)
qqPlot(modboth, main="Both", pch=19, cex=1.5)
```

## Residuales para el mejor modelo

```{r, fig.asp=1, fig.width=8}
par(mfrow=c(2, 2))
plot(modback, pch=19)
```

La ecuación del mejor modelo es la siguiente:

$$\hat{y}=4.59 + 2.60 x_5 + 0.22 x_8 -0.01 x_{10}$$

```{r}
require(rsm)
mod.rsm <- rsm(y ~ FO(x5) + x8 + x10, data = datis)
mod.rsm
par(mfrow = c(1, 2))
contour(mod.rsm, ~ x5 + x8, at = list(x10=0))
contour(mod.rsm, ~ x5 + x8, at = list(x10=1))
```

